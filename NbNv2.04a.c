#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    pot1,           sensorPotentiometer)
#pragma config(Sensor, in8,    ballTr,         sensorLineFollower)
#pragma config(Sensor, dgtl1,  clip1,          sensorDigitalIn)
#pragma config(Sensor, dgtl2,  clip2,          sensorDigitalIn)
#pragma config(Sensor, dgtl8,  Gr1,            sensorDigitalOut)
#pragma config(Sensor, dgtl9,  Gr2,            sensorDigitalOut)
#pragma config(Sensor, dgtl11, Rd1,            sensorDigitalOut)
#pragma config(Sensor, dgtl12, Rd2,            sensorDigitalOut)
#pragma config(Sensor, I2C_1,  ime1,           sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           fw1,           tmotorVex393TurboSpeed_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           Le,            tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           Roller,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           Re2,           tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           wheel5,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           Intake,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           punch,         tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           Le2,           tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           Re,            tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          fw2,           tmotorVex393TurboSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma competitionControl(Competition)
//#pragma autonomousDuration(20)
//#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"

float Batt = 0;
float vel  = 0;
float vel2 = 0;
float targetRPM = 0;
float targetPow = 0;
float mPow=0, P,I=0;
float acc=0, velP=0;

int   segment=0,  a=0, b=0;
unsigned long segmentEnd=0;


void LED(int A,int B,int C,int D)
{
	SensorValue[Gr1] = !A;
	SensorValue[Gr2] = !B;
	SensorValue[Rd1] = !C;
	SensorValue[Rd2] = !D;
}

void FlyWheel()
{
	if(vexRT[Btn8L] == 1) {targetPow = 64;	targetRPM = 136; I=0; segment=0; } // base
	if(vexRT[Btn8U] == 1) {targetPow = 53;	targetRPM = 118; I=0; segment=0; } // mid-field
	if(vexRT[Btn8R] == 1) {targetPow = 42;	targetRPM = 100; I=0; segment=0; } // at the bar
	if(vexRT[Btn8D] == 1) {targetPow =  0;	targetRPM =   0; I=0; segment=0; }

	if(vexRT[Btn6U]==1 && a==0) {targetRPM++; targetPow+=0.5; a=1;}	else if(vexRT[Btn6U]==0) a=0;
	if(vexRT[Btn6D]==1 && b==0) {targetRPM--; targetPow-=0.5; b=1;}	else if(vexRT[Btn6D]==0) b=0;

	short RPM = getMotorVelocity(fw1);

	Batt = (Batt * 7 + nImmediateBatteryLevel / 1000.0) / 8;


	if( segment == 2 && nPgmTime > segmentEnd  ) segment = 0;
	P=0;

	LED(0,0,0,0);

	if( RPM > 0 )
	{
		vel  = ( 5*vel  + RPM)/6;  // smoothed velocity
		vel2 = (15*vel2 + RPM)/16; // even more smoothed velocity
		float err = targetRPM - vel2;
		acc = 10*(vel - velP);
		velP = vel;
		if( abs(err) < 3.5 ) LED(1,1,0,0); // green
		else if( err > 6.5 ) LED(0,0,1,1); // red

		if( segment == 0 ) // aggressive acceleration
		{
			if( err > 0.5 ) P = err*err; // undershoot, kp>3
			else if( err < -3 ) P = err; // overshoot,  kp=2
			else segment=1;
		}

		if( segment == 1 &&  acc<-targetRPM/4.4 ) // ball is going trough 138->35, 120->30
		{
			segment = 2;
			segmentEnd = nPgmTime + 80; // do not increase motor power for the next 80ms
		}

		if( segment == 1 ) // maintain constant speed
		{
			P = err * 0.6; // kp=0.5
			I += err * (err>0 ? 0.001 : 0.003); // assymmetric ki, larger when overshooting
		}
	}

	float mp = ((6+7.623)/(6+Batt)) * (targetPow + P + I ); // scaling, it was tuned at 7.623v

	if( mp<0 ) mp=0;
	if( mp>127 ) mp=127;

	if( mp > mPow+7 )  // limit slew rate to 5 power units per 5 ms
		mPow = mPow+7;
	else mPow = mp;

	motor[fw1] = mPow + 0.5;
	motor[fw2] = mPow;

		clearLCDLine(0);
		clearLCDLine(1);

		displayLCDString(0,1,"V=");
		displayLCDNumber(0,3,vel2);
		displayLCDString(0,8,"B=");
		displayLCDNumber(0,10,Batt * 1000);
		displayLCDString(1,1,"M=");
		displayLCDNumber(1,3,mPow * 10);
		displayLCDString(1,8,"I=");
		displayLCDNumber(1,10,I * 1000);

		if(RPM == 0 && targetRPM > 0)
		{
			//clearLCDLine(0);
			//clearLCDLine(1);

			//displayLCDCenteredString(0,"IME may not be");
			//displayLCDCenteredString(1,"working");
		}
}


void pre_auton()
{
	//	bStopTasksBetweenModes = true;
}

task autonomous()
{
	unsigned long autoStart = nPgmTime;

	targetPow = 64;
	targetRPM = 136;
	I=0;
	segment=0;

	while(1)
	{
		FlyWheel();

		if( nPgmTime > autoStart+20800 /*&& nPgmTime < autoStart+4800 */ && sensorValue[clip1] == 0)
			motor[punch] = 127;
		else
			motor[punch] = 0;

		if( nPgmTime > autoStart+4900 && nPgmTime < autoStart+5500 ||
   			nPgmTime > autoStart+7700 && nPgmTime < autoStart+8400 ||
	    	nPgmTime > autoStart+10400 && nPgmTime < autoStart+11800 ||
	    	nPgmTime > autoStart+14200 /*&& nPgmTime < autoStart+15000*/ )
	    	motor[Intake] = 60*(8/Batt);
		else
			motor[Intake] = 0;

		delay(5);
	}
}


task usercontrol()
//task main()
{
	clearLCDLine(0);
	clearLCDLine(1);
	displayLCDPos(0, 0);
	displayNextLCDString("Startup");

	displayLCDCenteredString(1,"80K Magik VexMen");

	LED(0,0,0,0);
	while(true)
	{
		FlyWheel();

		if(vexRT[Btn7U] == 1) motor[punch] = 127;
		if(vexRT[Btn7D] == 1) motor[punch] = 0;

		motor[Le] = motor[Le2] = (abs(vexRT[Ch3]) > 25 ? vexRT[Ch3] : 0 );
  	motor[Re] = motor[Re2] = (abs(vexRT[Ch2]) > 25 ? vexRT[Ch2] : 0 );


  	motor[wheel5] = (abs(vexRT[Ch1]) > 25 ? vexRT[Ch1] : 0 );

		if(     vexRT[Btn5U] == 1) motor[Intake] = 50;
		else if(vexRT[Btn5D] == 1) motor[Intake] = -50;
		else motor[Intake] = 0;

		if(vexRT[Btn7R] == 1) motor[Roller] = 80;
		if(vexRT[Btn7L] == 1) motor[Roller] = 0;

		/*		datalogDataGroupStart();
		datalogAddValue( 0, vel );
		datalogAddValue( 1, mPow*10 );
		datalogAddValue( 2, P*10 );
		datalogAddValue( 3, I*10 );
		datalogAddValue( 4, D*10 );
		datalogDataGroupEnd();
		*/

		if(nLCDButtons == 6)
		{
			clearLCDLine(0);
			clearLCDLine(1);

			displayLCDString(0,1,"You Found the");
			displayLCDString(1,1,"Secret Code"); //AYE MY NAME IRVIN
		}

		delay(5);
	}
}
